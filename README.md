날씨정보 프로젝트 저장소 (2021.09.27. ~ 2021.10.22.) 
===


### 앱 구동 화면
|앱 실행 시|위치 정보 획득 성공 시 얼럿|위치 정보 획득 실패 시 얼럿|
|--|--|--|
|![simulator_screenshot_FD83F3C6-120D-44ED-BCA7-2CC1EC81986C](https://user-images.githubusercontent.com/57824307/138702685-8234462b-db6f-4f73-b27e-f6fe0710fdfb.png)|![simulator_screenshot_ABCAF2B1-D80A-42F1-AD58-18AB879C4908](https://user-images.githubusercontent.com/57824307/138702462-b78269fc-b150-485f-93c0-d9ff069a3a17.png)|![simulator_screenshot_BE02C4DD-B9F0-44B7-A0A0-E6827AB8DD4C](https://user-images.githubusercontent.com/57824307/138702520-c4e61b99-824e-4056-b5b4-f58ee2bbf8d8.png)|


[1. 파싱한 JSON 데이터와 매핑할 모델 설계](#----json---------------)

[2. `CodingKeys` 프로토콜의 활용](#2--codingkeys----------)

[3. 범용성과 재사용성, 유연성을 고려한 네트워킹 타입 구현](#3-------------------------------)

[4. 라이브러리 없이 URLSession을 활용하여 구현](#4----------urlsession---------)

[5. 다양한 에러들을 어떻게 핸들링하고 어디까지 전파할 것인지?](#5---------------------------------)


<br>


### 1. 파싱한 JSON 데이터와 매핑할 모델 설계

- 고민했던 점
    - 루얀: 타입을 JSON의 제공형식과 동일하게 맞추니 실제 App에서 사용하지 않는 데이터를 위한 모델의 형식을 만들고 있었다. 쓰지 않을 건데. 굳이..? 라는 생각

    ```swift=
    /// 예시
    {
      ...
      "dt": 1560350645,     // 구현할 앱에서는 요구하지 않을 수 있는 데이터
      "id": 420006353,      // 구현할 앱에서는 요구하지 않을 수 있는 데이터
      "cod": 200            // 구현할 앱에서는 요구하지 않을 수 있는 데이터
    }                         
    // 해당 데이터들에 대한 구현이 필요하지 않다고 판단됨.
    ```

    - 샬롯: 구조가 복잡해보였다.
    - 수박: 이름이 대부분 축약되어 있어서 파악하기 힘들었다(아래와 같은 부분)
        ![수박dt](https://i.imgur.com/E3Ki5Cx.png)

- 해결 과정
    - 루얀: [모델자동생성 페이지](https://app.quicktype.io/)를 통해 사전 구조를 파악하면서 구조 파악, API에서 제공하는 데이터 중 필요가 없는 부분에 대해서는 @tacocat 과의 대화 도중 Json이 담고 있는 데이터 >= 변환모델의 데이터인 경우에도 `Codable`이 제대로 작동하는 것을 알았다.
    - 샬롯: 모델을 직접 작성해보면서 구조가 파악되었다.
    - 수박: 샘플데이터와 함께 API를 제공하는 문서에서, 각각의 키에 대해서 설명하는 내용이 있어서 이를 참고하여 유추했으나, 그 와중에도 설명조차 축약되어 있는 부분이 있었다. 그래서 그러한 부분들에 대해서는 파악을 하지 않고 문서에서 제공하는 키를 그대로 사용하자고 말을 꺼냈다.
        - ![수박dt](https://i.imgur.com/tB0cSR9.png)
        - 데이터가 계산된 시점이라고 이해하고, calculatedTime이라고 명명하고 타입은 TimeInterval을 주게 되었다.

### 2. `CodingKeys` 프로토콜의 활용

- 고민했던 점
    - 루얀: API에서 제공하는 문서의 내용에서 제대로 이해하지 못한 값들을 모델내 프로퍼티로 변경하는 과정에 있어서 이해를 제대로 할 수 있는 키 값 결정에서 오류를 범할 수 있지 않을까?
    - 샬롯: 의미를 알 수 없는 키 값들이 있었는데 API문서에서 조차 설명이 없는 부분들이 있어서 파악하는데 어려움이 있었다. 
    - 수박: `1. 파싱한 JSON 데이터와 매핑할 모델 설계`와 크게 다르지 않은 내용인데, dt에 더해 특히 main과 sys라는 이름이 잘 와닿지 않았고 이를 프로젝트 내에서 명료하게 사용하기 위해서 CodingKey를 통해 어떤 이름으로 바꿀 것인지 고민을 하였다.

- 해결 과정
    - 루얀: 서버 API 문서를 제대로 분석하기? 사실 명확한 해결을 하지 못했다고 생각한다. 하지만 사용해야하는 데이터 중 API 문서만으로 이해하지 못했고설명이 부족한 데이터라면 서버 개발자와 커뮤니케이션하는 것도 방법이 되지 않을까?
    - 샬롯: 파악하기 힘든 이름은 마음대로 판단하여 변수로 사용했다가 헷갈릴 수 있어서 문서에서 제공하는 그대로 사용했던 것 같다.
    - 수박: sys라는 이름은 system인 것 같다고 미루어 짐작했으나, 이를 정말 system이라고 사용하기에는 판단할 요소가 부족했기 때문에 그대로 sys를 사용하게 되었다. main의 경우에는 모델을 계속 마주하는 과정에서 날씨에 관한 데이터이면서 이것의 main이 날씨의 온도와 같은 수치적인 정보를 표현하고 있다는 점에서 main이 더할나위 없이 적합하다고 결론을 내리고 그대로 main을 사용하게 되었다


### 3. 범용성과 재사용성, 유연성을 고려한 네트워킹 타입 구현
    
1. 네트워크를 거치지 않으면서도 결과를 테스트할 수 있는 타입 구현
    - SOLID 원칙 DIP를 준수하여 테스트 가능한 코드 구현
        - `URLSession` -> `URLSessionable` (의존성 주입 가능)
        ```swift=
        extension URLSession: URLSessionable { }
        
        struct NetworkManager {
            init(session: URLSessionable = URLSession.shared) {
                self.session = session
            }
        }
        ```

2. 고민할 점
    - URL을 만드는 부분이 현재 APIEndPoint.path가 많은 책임을 가지고 있는데 요청하거나 응답하는 데에 관여하는 타입들이 이것들을 가지고 있도록 분산하는 게 좋을 것 같다고 피드백을 받았다

### 4. 라이브러리 없이 URLSession을 활용하여 구현
| Category | Description |
|:---:|:---|
| shared | - 캐싱의 기본 구현: 현재의 구현방향인데 메모리 낭비?하는건 아닐까 하는 생각? `from 수박` |
| default | - 캐싱을 직접구현해야 함 |
| ephemeral | - 캐싱이 기본적으로 안됨. 이 앱의 목적으로는 더 적절해보일 수 있다고 생각함. `from 수박` |
| background | - 큰 데이터를 주고 받기 위한 세션인데 캐싱은 잘 모르겠음 <br> - 실행중이지 않을 때도 백그라운드에서 컨텐츠를 업로드하거나 다운로드할 수 있도록 함. |


### 5. 다양한 에러들을 어떻게 핸들링하고 어디까지 전파할 것인지?

1. Parser Error
    - 처음에는 커스텀 ParsingError를 정의하여 .decondigFail을 캐치하도록 decode를 정의했었으나
    - Unit Test도중 WeelkyWeatherForecast 파싱에 대한 테스트가 실패하여
    - 이에 대한 원인을 분석하던 도중 커스텀 에러로는 이 내용을 분석하는 게 불충분하다는 생각이 들었고
    - 각각의 DecodingError를 모두 캐치하도록 수정하였다

2. NetworkManager Error
    ![현재 구현된 NetworkManager Error](https://i.imgur.com/I8Thmpl.png)
    - 에러를 던지는 부분과 핸들링하는 부분이 코드의 흐름 상 적절한 위치에서 진행되야 하는데, network error handle 여부에 따라 decode error handle이 진행되는 것이 적절하게 이뤄졌다고 생각함.

